## БД

### Свойства СУБД

#### Sharding

Шардирование - это распределение данных между разными физическими серверами.
Данный процесс предполагает разнесение данных между отдельными шардами на основе некого ключа шардинга.
Связанные одинаковым значением ключа шардинга сущности группируются в набор данных по заданному ключа, а этот набор хранится в пределах одного физического шарда.

Например, в системах типа социальных сетей ключом для шардинга может быть ID пользователя, таким образом все данные пользователя будут храниться в обрабатываться на одном сервере, а не собираться по частям с нескольких.

#### Replication

Репликация - это синхронное/асинхронное копирование данных между несколькими серверами.
Ведущие сервера называют мастерами (master), а ведомые сервера - слейвами (slave).
Мастера используются для изменения данных, а слэйвы - для считывания.

В классической схеме репликации обычно один мастер и несколько слейвов, так как в большей части веб проектов операций чтения на несколько порядков больше, чем операций записи, одано в более сложной схеме репликации может быть и несколько мастеров.

Создание нескольких дополнительных slave-серверов позволяет снять с основного сервера нагрузку и повысить общую производительность системы, а также можно организовать слейвы под конкретныу ресурсоемкие задачи и таким образом, например, упростить составление серьезных аналитических отчетов, используемых для этих целей slave может быть нагружен на 100%, но на работу других пользователей приложения это не повлияет.

#### Partitioning

Партиционирование - это разбиение таблиц, содержащих большое количество записей, на логические части по неким выбранным критериям.
В большинстве случаев партиционирование выполняется по primary key.

### Реляционные СУБД (SQL)

#### В каких случаях использовать реляционные СУБД?

SQL подойдет, если требуется:
1. ссылочная целостность; 
2. надежная обработка транзакций;
3. обработка большого количества сложных запросов;
4. рутинный анализ данных.

#### Соответствие теореме [CAP](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_CAP)

В большинстве случае реляционные СУБД соответствуют CA.

#### Какие существуют нормальные формы?
- Первая нормальная форма (1NF) - Отношение находится в 1NF, если значения всех его атрибутов
  атомарны (неделимы).
- Вторая нормальная форма (2NF) - Отношение находится в 2NF, если оно находится в 1NF, и при
  этом все неключевые атрибуты зависят только от ключа целиком, а не от какой-то его части.
- Третья нормальная форма (3NF) - Отношение находится в 3NF, если оно находится в 2NF и все
  неключевые атрибуты не зависят друг от друга.
- Нормальная форма Бойса-Кодда, усиленная 3 нормальная форма (BCNF) - Отношение находится в
  BCNF, когда каждая её нетривиальная и неприводимая слева функциональная зависимость имеет в
  качестве своего детерминанта некоторый потенциальный ключ.
- Четвёртая нормальная форма (4NF) - Отношение находится в 4NF, если оно находится в 3NF и
  если в нем не содержатся независимые группы атрибутов, между которыми существует отношение
  «многие-ко-многим».
- Пятая нормальная форма (5NF) - Отношение находится в 5NF, когда каждая нетривиальная зависимость
  соединения в ней определяется потенциальным ключом (ключами) этого отношения.
- Шестая нормальная форма (6NF) - Отношение находится в 6NF, когда она удовлетворяет всем нетривиальным зависимостям соединения,
  т.е. когда она неприводима, то есть не может быть подвергнута дальнейшей декомпозиции без потерь.
  Каждая переменная отношения, которая находится в 6NF, также находится и в 5NF. Введена как обобщение пятой нормальной
  формы для хронологической базы данных.
- Доменно-ключевая нормальная форма (DKNF) - Отношение находится в DKNF, когда каждое наложенное на неё
  ограничение является логическим следствием ограничений доменов и ограничений ключей, наложенных на данное отношение.

---

#### Дайте определение терминам «простой», «составной», «потенциальный» и «альтернативный» ключ.
- **Простой** ключ состоит из одного атрибута (поля).
- **Составной** - из двух и более.
- **Потенциальный** ключ - простой или составной ключ, который уникально идентифицирует каждую запись набора данных.
  При этом потенциальный ключ должен обладать критерием неизбыточности: при удалении любого из полей набор полей перестает уникально идентифицировать запись.
  Из множества всех потенциальных ключей набора данных выбирают первичный ключ, все остальные ключи называют **альтернативными**.

---

#### Какие существуют индексы?
Индекс — объект базы данных, создаваемый с целью повышения производительности выборки данных.

**По порядку сортировки**
- упорядоченные — индексы, в которых элементы упорядочены;
- возрастающие;
- убывающие;
- неупорядоченные — индексы, в которых элементы неупорядоченны.

**По источнику данных**
- индексы по представлению;
- индексы по выражениям.

**По воздействию на источник данных**
- кластерный индекс - при определении в наборе данных физическое расположение данных перестраивается
  в соответствии со структурой индекса. Логическая структура набора данных в этом
  случае представляет собой скорее словарь, чем индекс. Данные в словаре физически упорядочены,
  например по алфавиту. Кластерные индексы могут дать существенное увеличение производительности
  поиска данных даже по сравнению с обычными индексами. Увеличение производительности
  особенно заметно при работе с последовательными данными.
- некластерный индекс — наиболее типичные представители семейства индексов. В отличие от
  кластерных, они не перестраивают физическую структуру набора данных, а лишь организуют ссылки
  на соответствующие записи. Для идентификации нужной записи в наборе данных некластерный
  индекс организует специальные указатели, включающие в себя: информацию об идентификационном
  номере файла, в котором хранится запись; идентификационный номер страницы соответствующих данных;
  номер искомой записи на соответствующей странице; содержимое столбца.

**По структуре**
- B*-деревья;
- B+-деревья;
- B-деревья;
- Хэши.

[Подробнее можно посмотреть здесь](https://github.com/enhorse/java-interview/blob/master/db.md#%D0%9A%D0%B0%D0%BA%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D1%8B-%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%BE%D0%B2-%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D1%83%D1%8E%D1%82)

---

#### Почему нельзя перегружать таблицу индексами?
Каждый индекс тратит дополнительное дисковое место, а также замедляет операции модификации данных.

---

#### Что такое транзакции?
Транзакция - это воздействие на базу данных, переводящее её из одного целостного состояния в
другое и выражаемое в изменении данных, хранящихся в базе данных.

**Свойства транзакций:**
- Атомарность (atomicity) гарантирует, что никакая транзакция не будет зафиксирована в системе
  частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной.
- Согласованность (consistency). Транзакция, достигающая своего нормального завершения и, тем самым, фиксирующая свои результаты,
  сохраняет согласованность базы данных.
- Изолированность (isolation). Во время выполнения транзакции параллельные транзакции не должны оказывать влияние на её результат.
- Долговечность (durability). Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании)
  изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу.

---

#### Что такое ACID?

* A (atomicity / атомарность) - Атомарность гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной. Поскольку на практике невозможно одновременно и атомарно выполнить всю последовательность операций внутри транзакции, вводится понятие «отката» (rollback): если транзакцию не удаётся полностью завершить, результаты всех её до сих пор произведённых действий будут отменены и система вернётся во «внешне исходное» состояние.
* C (consistency / согласованность) - Транзакция, достигающая своего нормального завершения (англ. end of transaction, EOT) и тем самым фиксирующая свои результаты, сохраняет согласованность базы данных. Другими словами, каждая успешная транзакция по определению фиксирует только допустимые результаты. Это условие является необходимым для поддержки свойства "устойчивости".
* I (isolation / изоляция) - Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат. Изолированность — требование дорогое, поэтому в реальных базах данных существуют режимы, не полностью изолирующие транзакцию (уровни изолированности, допускающие фантомное чтение и ниже).
* D (durability / устойчивость) - Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу. Другими словами, если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя.

Терминология ACID используется в контексте реляционных (также называемых SQL-like) СУБД.

Подробнее см. [здесь](https://ru.wikipedia.org/wiki/ACID)

---

#### Какие существуют виды "согласованности" (consistency)

* strong consistency models (например: strict, sequential и casual consistency);
* weak consistency models (например: local, general и eventual consistency).

Подробнее см. [здесь](https://en.wikipedia.org/wiki/Consistency_model)

#### Какие существуют уровни изоляции транзакций?

При параллельном выполнении транзакций возможны следующие проблемы:
- Lost update (потерянное обновление) — при одновременном изменении одного блока данных разными транзакциями
  теряются все изменения, кроме последнего;
- Dirty read («грязное» чтение) — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не
  подтвердится (откатится);
- Non-repeatable read (неповторяющееся чтение) — при повторном чтении в рамках одной транзакции ранее прочитанные
  данные оказываются изменёнными;
- Phantom reads (фантомное чтение) — одна транзакция в ходе своего выполнения несколько раз выбирает множество
  строк по одним и тем же критериям. Другая транзакция в интервалах между этими выборками добавляет строки или изменяет
  столбцы некоторых строк, используемых в критериях выборки первой транзакции, и успешно заканчивается. В результате
  получится, что одни и те же выборки в первой транзакции дают разные множества строк.

**Уровни изоляции**

- Read uncommitted (чтение незафиксированных данных):
    - допускает "dirty read";
- Read committed (чтение фиксированных данных):
    - предотвращает "dirty read";
- Repeatable read (повторяющееся чтение):
    - предотвращает "dirty read" и "non-repeatable read";
- Serializable (упорядочиваемость):
    - предотвращает "dirty read" и "non-repeatable read" и "phantom reads";

**Поддержка изоляции транзакций в реальных СУБД**

СУБД, обеспечивающие транзакционность, не всегда поддерживают все четыре уровня изоляции транзакций, при этом также
могут вводить дополнительные:
- PostgreSQL:
    - поддерживает: Read Committed (уровень по умолчанию), Repeatable Read, Serializable;
- Oracle:
    - поддерживает: Read Committed (уровень по умолчанию);
- Mysql:
    - поддерживает: Read Committed, Repeatable Read (уровень по умолчанию).

Подробнее см. [здесь](https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_%D0%B8%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9).

---

### Нереляционные СУБД (NoSQL)

#### В каких случаях использовать нереляционные СУБД?

NoSQL подойдет, если требуется:
1. очень большой объем данных;
2. гибкость схемы: хорошо подходит для ситуаций, где схема данных может быстро изменяться или она не полностью определена;
3. горизонтальное масштабирование.

#### Соответствие теореме [CAP](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_CAP)

В большинстве случае нереляционные СУБД соответствуют AP.

#### Что такое BASE?

* BA (Basically Available / базовая доступность) - На каждый запрос будет предоставлен ответ, даже если он является системным сбоем или не возвращает данные.
* S (Soft State / мягкое состояние) - Состояние системы может меняться со временем, даже если нет операций чтения или записи, т.к. система продолжает изменять данные для достижения их согласованности (см. eventual consistency).
* E (Eventual Consistency / согласованность в конечном счёте) - Данные могут оказываться в согласованном состоянии не сразу, но в конечном итоге всегда приходят в такое состояние. При этом, чтения в системе по-прежнему доступны, даже если они могут не давать правильный ответ из-за несогласованности.

Терминология BASE используется в контексте нереляционных (также называемых NoSQL) СУБД.

Подробнее см. [здесь](https://medium.com/geekculture/acid-vs-base-in-databases-1bcad774da26)
